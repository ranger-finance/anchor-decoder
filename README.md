# anchor-decoder

A procedural macro to help with decoding Solana accounts and instructions for programs written with the [Anchor](https://github.com/coral-xyz/anchor) framework.

Note: this tool relies on IDLs generated by Anchor 0.30.0. Fortunately, there's a [CLI command](https://www.anchor-lang.com/docs/updates/release-notes/0-30-1#convert-legacy-idls) to help convert legacy IDLs to the new format.

## Usage

Add the crate to your `Cargo.toml`, and point the macro at your IDL:

```rust
use anchor_decoder::anchor_idl;

#[anchor_idl("./idl.json")]
pub const ID: Pubkey = crate::ID;
```

You can also call the macro multiple times in the same files by using separate modules.

```rust
pub mod production {
    use anchor_decoder_gen::anchor_idl;
    #[anchor_idl("./production.json")]

    pub const ID: Pubkey = crate::ID;
}

pub mod staging {
    use anchor_decoder_gen::anchor_idl;
    #[anchor_idl("./staging.json")]

    pub const ID: Pubkey = crate::ID;
}
```

## Using Decoders

I recommend creating separate crates for each parser. You can then install and import crates as needed. Assume you have a separate crate called `program_decoder`. You can then use the decoders as follows:

### Decode instructions

```rust
use program_decoder::{decode_instruction, DecodedInstruction, Instruction1, Instruction2};

let ix: CompiledInstruction = ...;
let account_keys: Vec<Pubkey> = ...;

match decode_instruction(&ix.data) {
    // matches the decoded instructions, with or without ix args
    Some(DecodedInstruction::Instruction1) => {
        // convert the array of accounts into a map based on IDL definition
        let accounts_map = Instruction1::map_accounts(account_keys);
        println!("Instruction1: {:?}", accounts_map);
    }
    Some(DecodedInstruction::Instruction2(decoded)) => {
        let accounts_map = Instruction2::map_accounts(account_keys);
        // can now access Instruction2 arg fields
        println!("Instruction2: {:?}, data: {:?}", accounts_map, decoded);
    }
    // handle the case when no match arms are found
    None => {
        println!("Failed to decode PROgraM1111111111111111111111111 instruction")
    }
};
```

### Decode accounts

```rust
use program_decoder::{decode_account, DecodedAccount, Account1};

let account_data: Vec<u8> = ...;
let account_key: Pubkey = ...;

// account decoder shown here, but it works the same for `decode_instruction`
match decode_account(&account_data) {
        Some(DecodedAccount::Account1(decoded)) => {
        // can now access Account1 struct fields
        println!("Account1: {:?}", decoded);
    }
    // handle the case when no match arms are found
    None => println!("Failed to decode PROgraM1111111111111111111111111 account: {:?}", account_key),
}
```

There are more examples in the [examples/](https://github.com/ranger-finance/anchor-decoder/tree/master/examples) directory.

## License

The project is licensed under [Apache 2.0](./LICENSE).

Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion by you, as defined in the Apache-2.0 license, shall be licensed as above, without any additional terms or conditions.

## Contribution

Any contributions are welcome. If you notice there's an IDL that doesn't breaks the macro, please open an issue or submit a pull request.
